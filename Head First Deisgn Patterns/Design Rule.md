# 고수의 디자인 원칙

1. 애플리케이션에서 **달라지는 부분**을 찾아내고, 달라지지 않는 부분으로부터 **분리**시킨다.

2. 구현이 아닌 **인터페이스**에 맞춰서 프로그래밍한다.

3. 상속보다는 **구성**을 활용한다.

4. **서로 상호작용하는 객체 사이**에서는 가능하면 **느슨하게 결합**하는 디자인을 사용해야 한다.

5. 클래스는 **확장에 대해서는 열려 있어야** 하지만, **코드 변경에 대해서는 닫혀 있어야**한다.  
   OCP (Open-Closed Principle)

6. **의존성 뒤집기 원칙(Dependency Inversion Principle)**
   **추상환된 것**에 **의존하도록** 만들어라. 구상 클래스에 의존하도록 만들지 않도록 한다.
   고수준 구성요소가 저수준 구성요소에 의존하면 안 된다.
   * 어떤 변수에도 **구상 클래스에 대한 레퍼런스를 저장하지 말자**
   * **구상 클래스에서 유도된 클래스**를 만들지 말자
   * 베이스 클래스에 **이미 구현되어 있던 메서드**를 오버라이드하지 말자

7. **최소 지식 원칙** : 결합도를 낮추기 위한 원칙, **직접적으로 알고 있는** 객체 줄이기
   * 어떤 메서드에서든지 아래 종류의 객체의 메소드만을 호출하면 된다.
     * 객체 자체
     * 메서드에 매개변수로 전달된 객체
     * 그 메서드에서 생성하거나 인스턴스를 만든 객체
     * 그 객체에 속하는 구성요소
   * **데메테르의 법칙**과 같은 단어

8. **할리우드 원칙(Hollywood Principle)**
   * **고수준의 구성요소**만이 **저수준 구성요소**가 언제 어떤 식으로 사용할지를 정하는 방식
   * 즉, **고수준 구성요소 만이 먼저 연락**할 수 있는 방식
   * **의존성 부패(dependency rot) 방지**
     * 의존성 부패란?: 어떤 고수준의 구성요소가 저수준의 구성요소에 의존하고 계속해서 다른 구성요소에 의존하는 것과 같은 식으로 의존성이 복잡하게 꼬여있는 상황
   * Ex) 템플릿 메서드 패턴, 팩토리 메서드 패턴, 옵저버 패턴, 스트래티지 패턴 등

9. **단일 역할 원칙**
   * 클래스를 **바꾸는 이유**는 **한 가지 뿐**이어야 한다.
   * 즉, 하나의 클래스는 **하나의 역할**만 가지고 있어야 한다.
   * 만약, 클래스가 **두 개 이상의 역할**을 가지고 있다면?
     1. 역할 하나를 **코드 변화의 가능성**으로 보았을 때
     2. 그 클래스는 두 가지 이상의 코드 변화의 가능성이 있다
     3. 코드를 수정하면 클래스를 참조하는 클래스도 수정해야 한다.
   * **응집도**
     * 한 클래스 또는 모듈이 특정 목적 또는 역할을 **얼마나 일관되게 지원**하는지를 나타내는 척도